// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pbs/filepb/file.proto

package filepb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type FileChunkRequest struct {
	Start                int64    `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	FileHash             string   `protobuf:"bytes,2,opt,name=FileHash,proto3" json:"FileHash,omitempty"`
	PieceSize            int64    `protobuf:"varint,3,opt,name=pieceSize,proto3" json:"pieceSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileChunkRequest) Reset()         { *m = FileChunkRequest{} }
func (m *FileChunkRequest) String() string { return proto.CompactTextString(m) }
func (*FileChunkRequest) ProtoMessage()    {}
func (*FileChunkRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_afd6febda9538843, []int{0}
}

func (m *FileChunkRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileChunkRequest.Unmarshal(m, b)
}
func (m *FileChunkRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileChunkRequest.Marshal(b, m, deterministic)
}
func (m *FileChunkRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileChunkRequest.Merge(m, src)
}
func (m *FileChunkRequest) XXX_Size() int {
	return xxx_messageInfo_FileChunkRequest.Size(m)
}
func (m *FileChunkRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FileChunkRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FileChunkRequest proto.InternalMessageInfo

func (m *FileChunkRequest) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *FileChunkRequest) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *FileChunkRequest) GetPieceSize() int64 {
	if m != nil {
		return m.PieceSize
	}
	return 0
}

type FileChunkResponse struct {
	Start                int64    `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	PieceHash            string   `protobuf:"bytes,2,opt,name=pieceHash,proto3" json:"pieceHash,omitempty"`
	Chunk                []byte   `protobuf:"bytes,3,opt,name=chunk,proto3" json:"chunk,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileChunkResponse) Reset()         { *m = FileChunkResponse{} }
func (m *FileChunkResponse) String() string { return proto.CompactTextString(m) }
func (*FileChunkResponse) ProtoMessage()    {}
func (*FileChunkResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_afd6febda9538843, []int{1}
}

func (m *FileChunkResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileChunkResponse.Unmarshal(m, b)
}
func (m *FileChunkResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileChunkResponse.Marshal(b, m, deterministic)
}
func (m *FileChunkResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileChunkResponse.Merge(m, src)
}
func (m *FileChunkResponse) XXX_Size() int {
	return xxx_messageInfo_FileChunkResponse.Size(m)
}
func (m *FileChunkResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FileChunkResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FileChunkResponse proto.InternalMessageInfo

func (m *FileChunkResponse) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *FileChunkResponse) GetPieceHash() string {
	if m != nil {
		return m.PieceHash
	}
	return ""
}

func (m *FileChunkResponse) GetChunk() []byte {
	if m != nil {
		return m.Chunk
	}
	return nil
}

type HasFileRequest struct {
	FileHash             string   `protobuf:"bytes,1,opt,name=FileHash,proto3" json:"FileHash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HasFileRequest) Reset()         { *m = HasFileRequest{} }
func (m *HasFileRequest) String() string { return proto.CompactTextString(m) }
func (*HasFileRequest) ProtoMessage()    {}
func (*HasFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_afd6febda9538843, []int{2}
}

func (m *HasFileRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HasFileRequest.Unmarshal(m, b)
}
func (m *HasFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HasFileRequest.Marshal(b, m, deterministic)
}
func (m *HasFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HasFileRequest.Merge(m, src)
}
func (m *HasFileRequest) XXX_Size() int {
	return xxx_messageInfo_HasFileRequest.Size(m)
}
func (m *HasFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HasFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HasFileRequest proto.InternalMessageInfo

func (m *HasFileRequest) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

type HasFileResponse struct {
	HasFlag              bool     `protobuf:"varint,1,opt,name=HasFlag,proto3" json:"HasFlag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HasFileResponse) Reset()         { *m = HasFileResponse{} }
func (m *HasFileResponse) String() string { return proto.CompactTextString(m) }
func (*HasFileResponse) ProtoMessage()    {}
func (*HasFileResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_afd6febda9538843, []int{3}
}

func (m *HasFileResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HasFileResponse.Unmarshal(m, b)
}
func (m *HasFileResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HasFileResponse.Marshal(b, m, deterministic)
}
func (m *HasFileResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HasFileResponse.Merge(m, src)
}
func (m *HasFileResponse) XXX_Size() int {
	return xxx_messageInfo_HasFileResponse.Size(m)
}
func (m *HasFileResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HasFileResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HasFileResponse proto.InternalMessageInfo

func (m *HasFileResponse) GetHasFlag() bool {
	if m != nil {
		return m.HasFlag
	}
	return false
}

func init() {
	proto.RegisterType((*FileChunkRequest)(nil), "pbs.fileChunkRequest")
	proto.RegisterType((*FileChunkResponse)(nil), "pbs.fileChunkResponse")
	proto.RegisterType((*HasFileRequest)(nil), "pbs.hasFileRequest")
	proto.RegisterType((*HasFileResponse)(nil), "pbs.hasFileResponse")
}

func init() {
	proto.RegisterFile("pbs/filepb/file.proto", fileDescriptor_afd6febda9538843)
}

var fileDescriptor_afd6febda9538843 = []byte{
	// 291 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x51, 0x4f, 0x4b, 0xfb, 0x40,
	0x14, 0xfc, 0xed, 0x2f, 0xd8, 0xa6, 0x4f, 0xf1, 0xcf, 0xda, 0x4a, 0x08, 0x3d, 0x94, 0x9c, 0x02,
	0x4a, 0x22, 0x0a, 0x5e, 0x05, 0x85, 0xd2, 0xa3, 0xa4, 0x37, 0xc1, 0xc3, 0x6e, 0x78, 0x26, 0x8b,
	0x21, 0xbb, 0x66, 0xb7, 0x1e, 0xfc, 0x00, 0x7e, 0x6e, 0xd9, 0x4d, 0xd3, 0x26, 0x05, 0x4f, 0xcb,
	0x0c, 0x33, 0x6f, 0x66, 0xdf, 0x83, 0x99, 0xe2, 0x3a, 0x7d, 0x17, 0x15, 0x2a, 0xee, 0x9e, 0x44,
	0x35, 0xd2, 0x48, 0xea, 0x29, 0xae, 0xc3, 0x79, 0x21, 0x65, 0x51, 0x61, 0xca, 0x94, 0x48, 0x59,
	0x5d, 0x4b, 0xc3, 0x8c, 0x90, 0xb5, 0x6e, 0x25, 0x11, 0x87, 0x73, 0x6b, 0x78, 0x2e, 0x37, 0xf5,
	0x47, 0x86, 0x9f, 0x1b, 0xd4, 0x86, 0x4e, 0xe1, 0x48, 0x1b, 0xd6, 0x98, 0x80, 0x2c, 0x48, 0xec,
	0x65, 0x2d, 0xa0, 0x21, 0xf8, 0x4b, 0x51, 0xe1, 0x8a, 0xe9, 0x32, 0xf8, 0xbf, 0x20, 0xf1, 0x24,
	0xdb, 0x61, 0x3a, 0x87, 0x89, 0x12, 0x98, 0xe3, 0x5a, 0x7c, 0x63, 0xe0, 0x39, 0xd7, 0x9e, 0x88,
	0xde, 0xe0, 0xa2, 0x97, 0xa1, 0x95, 0xac, 0x35, 0xfe, 0x11, 0xd2, 0x0d, 0xea, 0xa5, 0xec, 0x09,
	0xeb, 0xc9, 0xed, 0x10, 0x17, 0x71, 0x92, 0xb5, 0x20, 0xba, 0x81, 0xd3, 0x92, 0x69, 0xdb, 0xa5,
	0xfb, 0x40, 0xbf, 0x2a, 0x19, 0x56, 0x8d, 0xae, 0xe1, 0x6c, 0xa7, 0xde, 0x56, 0x09, 0x60, 0xbc,
	0x62, 0x7a, 0x59, 0xb1, 0xc2, 0xa9, 0xfd, 0xac, 0x83, 0x77, 0x3f, 0x04, 0x8e, 0xad, 0x74, 0x8d,
	0xcd, 0x97, 0xc8, 0x91, 0x3e, 0x82, 0x5f, 0xa0, 0x79, 0xb1, 0x85, 0xe8, 0x2c, 0x51, 0x5c, 0x27,
	0x87, 0xcb, 0x0b, 0xaf, 0x0e, 0xe9, 0x36, 0x24, 0xfa, 0x17, 0x93, 0x5b, 0x42, 0x1f, 0x60, 0xbc,
	0x4d, 0xa7, 0x97, 0x4e, 0x38, 0x6c, 0x1e, 0x4e, 0x87, 0x64, 0xe7, 0x7d, 0xf2, 0x5f, 0x47, 0xed,
	0x79, 0xf9, 0xc8, 0xdd, 0xed, 0xfe, 0x37, 0x00, 0x00, 0xff, 0xff, 0xa6, 0xa9, 0x7d, 0xf5, 0xf3,
	0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// FileServiceClient is the client API for FileService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FileServiceClient interface {
	GetPiece(ctx context.Context, opts ...grpc.CallOption) (FileService_GetPieceClient, error)
	HasFile(ctx context.Context, in *HasFileRequest, opts ...grpc.CallOption) (*HasFileResponse, error)
}

type fileServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFileServiceClient(cc grpc.ClientConnInterface) FileServiceClient {
	return &fileServiceClient{cc}
}

func (c *fileServiceClient) GetPiece(ctx context.Context, opts ...grpc.CallOption) (FileService_GetPieceClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FileService_serviceDesc.Streams[0], "/pbs.FileService/getPiece", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileServiceGetPieceClient{stream}
	return x, nil
}

type FileService_GetPieceClient interface {
	Send(*FileChunkRequest) error
	Recv() (*FileChunkResponse, error)
	grpc.ClientStream
}

type fileServiceGetPieceClient struct {
	grpc.ClientStream
}

func (x *fileServiceGetPieceClient) Send(m *FileChunkRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *fileServiceGetPieceClient) Recv() (*FileChunkResponse, error) {
	m := new(FileChunkResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileServiceClient) HasFile(ctx context.Context, in *HasFileRequest, opts ...grpc.CallOption) (*HasFileResponse, error) {
	out := new(HasFileResponse)
	err := c.cc.Invoke(ctx, "/pbs.FileService/hasFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FileServiceServer is the server API for FileService service.
type FileServiceServer interface {
	GetPiece(FileService_GetPieceServer) error
	HasFile(context.Context, *HasFileRequest) (*HasFileResponse, error)
}

// UnimplementedFileServiceServer can be embedded to have forward compatible implementations.
type UnimplementedFileServiceServer struct {
}

func (*UnimplementedFileServiceServer) GetPiece(srv FileService_GetPieceServer) error {
	return status.Errorf(codes.Unimplemented, "method GetPiece not implemented")
}
func (*UnimplementedFileServiceServer) HasFile(ctx context.Context, req *HasFileRequest) (*HasFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasFile not implemented")
}

func RegisterFileServiceServer(s *grpc.Server, srv FileServiceServer) {
	s.RegisterService(&_FileService_serviceDesc, srv)
}

func _FileService_GetPiece_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FileServiceServer).GetPiece(&fileServiceGetPieceServer{stream})
}

type FileService_GetPieceServer interface {
	Send(*FileChunkResponse) error
	Recv() (*FileChunkRequest, error)
	grpc.ServerStream
}

type fileServiceGetPieceServer struct {
	grpc.ServerStream
}

func (x *fileServiceGetPieceServer) Send(m *FileChunkResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *fileServiceGetPieceServer) Recv() (*FileChunkRequest, error) {
	m := new(FileChunkRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _FileService_HasFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HasFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).HasFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbs.FileService/HasFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).HasFile(ctx, req.(*HasFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _FileService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pbs.FileService",
	HandlerType: (*FileServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "hasFile",
			Handler:    _FileService_HasFile_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "getPiece",
			Handler:       _FileService_GetPiece_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pbs/filepb/file.proto",
}
